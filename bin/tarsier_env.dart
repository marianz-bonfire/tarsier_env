import 'dart:io';

import 'package:tarsier_env/src/tarsier_env_base.dart';
import 'package:tarsier_logger/tarsier_logger.dart';

/// Entry point for the `tarsier_env` command-line tool.
///
/// This tool provides commands to manage `.env` files and
/// automatically integrate them into your Flutter project.
///
/// Usage:
/// ```sh
/// dart run tarsier_env <command>
/// ```
///
/// Available commands:
/// - `generate`: Generates `env.dart` from the `.env` file and updates `main.dart`.
/// - `new`: Creates a default `.env` file and adds it to `.gitignore`.
void main(List<String> args) async {
  if (args.isEmpty) {
    _printUsage();
    return;
  }

  switch (args[0]) {
    case 'generate':
      String outputFilename =
          await _generateEnvFileCommand(args.skip(1).toList());
      await _updateMainDartWithEnv(outputFilename);
      await _addToGitignore('.env');
      break;
    case 'new':
      await _createNewEnvFile();
      await _addToGitignore('.env');
      _updatePubspec();
      break;
    default:
      Console.error('Unknown command: ${args[0]}');
      _printUsage();
  }
}

/// Prints the usage guide for the `tarsier_env` CLI tool.
void _printUsage() {
  Console.info('Usage: dart run tarsier_env:<command>');
  Console.info('');
  Console.info('Commands:');
  Console.info('  generate    Generate env.dart from .env file.');
  Console.info('  new         Create a default .env file.');
}

/// Generates `env.dart` from `.env` file.
///
/// This command reads environment variables from a `.env` file and generates
/// a Dart file that defines constants for each variable.
///
/// - [args]: Optional arguments specifying the output folder for `env.dart`.
Future<String> _generateEnvFileCommand(List<String> args) async {
  const inputFileName = '.env'; // Default .env file name
  const defaultMainFilePath = 'lib/main.dart'; // Default location of main.dart
  final defaultOutputFileName =
      'env.dart'; // Default file name for generated env.dart

  // Determine output folder
  String outputFolderPath;
  if (args.isEmpty) {
    // If no argument is provided, use the location of main.dart
    final mainFile = File(defaultMainFilePath);
    if (!await mainFile.exists()) {
      throw Exception('main.dart not found at $defaultMainFilePath. '
          'Please provide a path as an argument.');
    }
    outputFolderPath = File(defaultMainFilePath).parent.path;
  } else {
    // Use the custom folder provided as an argument
    outputFolderPath = 'lib/${args[0]}';
  }
  /*
  final cleanedOutputFolderPath = outputFolderPath.endsWith('/')
      ? outputFolderPath.substring(0, outputFolderPath.length - 1)
      : outputFolderPath;

   */

  final cleanedOutputFolderPath =
      outputFolderPath.replaceAll(RegExp(r'\/+$'), '');

  final outputFileName = '$cleanedOutputFolderPath/$defaultOutputFileName';

  // Ensure the output directory exists
  await _ensureDirectoryExists(outputFolderPath);

  // Load and parse the .env file
  final envVars = await loadEnvFile(inputFileName);

  // Generate the Dart file
  await _generateEnvFile(outputFileName, envVars);

  Console.success('Successfully generated $outputFileName from $inputFileName');
  return outputFileName.replaceAll("lib/", "");
}

/// Generates a Dart file with getters for environment variables.
///
/// The generated file contains a static `Map<String, String>` with the parsed
/// variables, and a getter for each variable that retrieves its value from the map.
///
/// - [outputFileName]: The path where the Dart file will be created.
/// - [envVars]: A `Map<String, String>` containing the parsed environment variables.
Future<void> _generateEnvFile(
    String outputFileName, Map<String, String> envVars,
    {bool addValueOnMapVariables = false}) async {
  final buffer = StringBuffer();

  // Generate the Dart file content
  buffer.writeln('// AUTO-GENERATED FILE. DO NOT EDIT.');
  buffer.writeln('// Generated by tarsier_env script.');
  buffer.writeln('import \'package:flutter/services.dart\' show rootBundle;');

  buffer.writeln('import \'package:tarsier_env/tarsier_env.dart\';\n');
  buffer.writeln('/// A class to access environment variables.');
  buffer.writeln('///');
  buffer.writeln(
      '/// Environment variables are stored in a static map and can be accessed using getters.');

  buffer.writeln('class Env {');
  buffer.writeln('  static Map<String, String> _variables = {};\n');

  // Add environment variables to the map
  if (addValueOnMapVariables) {
    envVars.forEach((key, value) {
      buffer.writeln('    \'$key\': \'$value\',');
    });
    buffer.writeln('  };\n');
  }

  buffer.writeln('  // This function must be called in the main function to');
  buffer.writeln('  // initialize first all environment variables');
  buffer.writeln('  static init() async {');
  buffer.writeln('    //_variables = await loadEnvFile(\'.env\');');
  buffer.writeln("    final content = await rootBundle.loadString('.env');");
  buffer.writeln("    _variables =  parseEnv(content.split('\\n'));");
  buffer.writeln('  }\n');

  buffer.writeln('  static Map<String, String> get vars => _variables;');
  // Generate getters
  envVars.forEach((key, _) {
    final getterName = _toCamelCase(key);
    buffer.writeln('  static String? get $getterName => _variables[\'$key\'];');
  });

  buffer.writeln('}\n');

  // Write to the output file
  final file = File(outputFileName);
  if (await file.exists()) {
    await file.delete(); // Delete the existing file
  }
  await file.writeAsString(buffer.toString());
}

/// Creates a default `.env` file with boilerplate content.
///
/// If a `.env` file already exists, no changes are made.
Future<void> _createNewEnvFile() async {
  const envFileName = '.env';

  // Check if the `.env` file already exists
  final envFile = File(envFileName);
  if (await envFile.exists()) {
    Console.error('The .env file already exists.');
    return;
  }

  // Get the project folder name for `APP_NAME`
  final projectFolderName = Directory.current.uri.pathSegments.lastWhere(
      (segment) => segment.isNotEmpty,
      orElse: () => 'unknown_project');

  // Default content for the `.env` file
  const defaultEnvContent = '''
# AUTO-GENERATED FILE. 
# YOU CAN EDIT/ADD MORE KEYS AND ITS VALUE.
# Generated by tarsier_env script.

APP_NAME="<app name>"
APP_ENV=local
APP_KEY=null
APP_DEBUG=true
APP_URL=http://localhost

# REDIS configuration
REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379

# Email configuration
MAIL_DRIVER=smtp
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USERNAME=tarsier.dev@gmail.com
MAIL_PASSWORD=null
MAIL_ENCRYPTION=tls

# AWS configuration
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=

# Configuration for Pusher
PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_APP_CLUSTER=eu
''';
  final content =
      defaultEnvContent.replaceFirst('<app name>', projectFolderName);

  // Write the default content to the `.env` file
  await envFile.writeAsString(content);
  Console.success('Created .env file with default content.');
}

/// Adds the given file name to `.gitignore` if not already present.
///
/// - [fileName]: The file name to add, typically `.env`.
Future<void> _addToGitignore(String fileName) async {
  const gitignorePath = '.gitignore';

  final gitignoreFile = File(gitignorePath);
  if (!await gitignoreFile.exists()) {
    Console.error('$gitignorePath not found. Creating a new one.');
    await gitignoreFile.writeAsString('$fileName\n');
    Console.success('Added $fileName to $gitignoreFile.');
    return;
  }

  final lines = await gitignoreFile.readAsLines();
  if (!lines.contains(fileName)) {
    await gitignoreFile.writeAsString('$fileName\n', mode: FileMode.append);
    Console.success('Added $fileName to $gitignoreFile.');
  } else {
    Console.warning('$fileName is already in $gitignoreFile.');
  }
}

/// Inserts `Env.init()` and imports the dynamically generated `env.dart` into `main.dart`.
///
/// This method ensures that:
/// 1. The `env.dart` file is imported with the correct path.
/// 2. The `Env.init()` method is called inside the existing main() function.
///
/// - If no arguments are provided during the generation, the import will be `import 'env.dart';`
/// - If the generation uses a path like `common/environment`, the import will be `import 'common/environment/env.dart';`
Future<void> _updateMainDartWithEnv(String generatedEnvPath) async {
  final formattedEnvPath = generatedEnvPath.endsWith('/')
      ? generatedEnvPath.substring(0, generatedEnvPath.length - 1)
      : generatedEnvPath;

  final importPath = formattedEnvPath.endsWith('env.dart')
      ? formattedEnvPath
      : '$formattedEnvPath/env.dart';

  const envInitCall = 'await Env.init();';
  const widgetsInitCall = 'WidgetsFlutterBinding.ensureInitialized();';

  final mainFilePath = 'lib/main.dart';
  final mainFile = File(mainFilePath);

  if (!await mainFile.exists()) {
    Console.error('$mainFilePath not found. Skipping Env.init() insertion.');
    return;
  }

  final lines = await mainFile.readAsLines();
  bool hasImport = false;
  bool hasEnvInit = false;
  bool hasWidgetsInit = false;
  bool hasMainFunction = false;
  final buffer = StringBuffer();
  bool importInserted = false;
  bool insideMain = false;

  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    var trimmedLine = lines[i].trim();

    // Detect existing import
    if (trimmedLine == "import '$importPath';") {
      hasImport = true;
    }

    // Detect existing Env.init()
    if (trimmedLine == envInitCall) {
      hasEnvInit = true;
      continue; // Skip duplicate line
    }

    // Detect existing WidgetsFlutterBinding.ensureInitialized()
    if (trimmedLine == widgetsInitCall) {
      hasWidgetsInit = true;
      continue; // Skip duplicate line
    }

    // Detect the main function
    if (trimmedLine.startsWith('void main(') ||
        trimmedLine.startsWith('Future<void> main(')) {
      hasMainFunction = true;
      insideMain = true;
    }

    // Add import if missing (before first import statement)
    if (!hasImport && line.startsWith('import ') && !importInserted) {
      buffer.writeln("import '$importPath';");
      importInserted = true;
    }

    // Write the original line with its original indentation
    buffer.writeln(line);

    // Ensure `WidgetsFlutterBinding.ensureInitialized();` and `await Env.init();` are added in correct order
    if (insideMain && line.contains('{')) {
      if (!hasWidgetsInit) {
        buffer.writeln('  $widgetsInitCall'); // Keep the correct indentation
        hasWidgetsInit = true;
      }
      if (!hasEnvInit) {
        buffer.writeln('  $envInitCall'); // Keep the correct indentation
        hasEnvInit = true;
      }
    }
  }

  // Ensure import is added at the top if it wasn't inserted before
  if (!importInserted && !hasImport) {
    buffer.writeln("import '$importPath';");
  }

  // Check if `main()` was found; if not, log a warning
  if (!hasMainFunction) {
    Console.warning(
        'Warning: main function not found in $mainFilePath. Skipping Env.init() insertion.');
  } else {
    // Write updated content to `main.dart`
    await mainFile.writeAsString(buffer.toString());
    Console.success(
        'Updated main.dart with WidgetsFlutterBinding.ensureInitialized(), Env.init(), and import for $importPath');
  }
}

void _updatePubspec() {
  const assetPath = '.env';
  final file = File('pubspec.yaml');

  if (!file.existsSync()) {
    Console.error('Error: pubspec.yaml not found.');
    return;
  }

  List<String> lines = file.readAsLinesSync();
  bool flutterSectionFound = false;
  bool assetsSectionFound = false;
  bool envExists = false;
  int flutterIndex = -1;
  int assetsIndex = -1;

  for (int i = 0; i < lines.length; i++) {
    final line = lines[i].trim();

    if (line.startsWith('flutter:')) {
      flutterSectionFound = true;
      flutterIndex = i;
    }

    if (flutterSectionFound && line.startsWith('assets:')) {
      assetsSectionFound = true;
      assetsIndex = i;
    }

    if (line.contains(assetPath)) {
      envExists = true;
      break;
    }
  }

  if (envExists) {
    Console.warning('✔ assets/.env already exists in pubspec.yaml');
    return;
  }

  if (assetsSectionFound) {
    // Add under existing assets:
    lines.insert(assetsIndex + 1, '    - $assetPath');
  } else if (flutterSectionFound) {
    // Insert new assets: section under flutter:
    lines.insert(flutterIndex + 1, '  assets:\n    - $assetPath');
  } else {
    // If flutter: is missing, add everything at the end
    lines.add('\nflutter:\n  assets:\n    - $assetPath');
  }

  // Write back the modified file
  file.writeAsStringSync(lines.join('\n'));

  Console.success(
      '✔ Added assets/.env to pubspec.yaml. Run `flutter pub get` to apply changes.');
}

/// Ensures that the specified directory exists.
///
/// Creates the directory recursively if it does not already exist.
///
/// - [folderPath]: The path of the directory to check or create.
Future<void> _ensureDirectoryExists(String folderPath) async {
  final directory = Directory(folderPath);
  if (!await directory.exists()) {
    await directory.create(recursive: true);
  }
}

/// Converts a string to camelCase for Dart property names.
///
/// - [key]: The key to convert.
/// Returns a camelCase version of the key.
String _toCamelCase(String key) {
  return key.toLowerCase().replaceAllMapped(RegExp(r'(_[a-z])'),
      (match) => match.group(0)!.substring(1).toUpperCase());
}
